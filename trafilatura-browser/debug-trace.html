<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>è¿½è¸ªè°ƒè¯• - æŸ¥æ‰¾é‡å¤æºå¤´</title>
<style>
  body { font-family: monospace; padding: 20px; background: #f5f5f5; }
  .step { 
    margin: 20px 0; 
    padding: 20px; 
    background: white; 
    border-left: 4px solid #667eea;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  h2 { color: #667eea; margin-top: 0; }
  pre { 
    background: #2d2d2d; 
    color: #f8f8f2; 
    padding: 15px; 
    overflow-x: auto; 
    border-radius: 4px;
    font-size: 12px;
    line-height: 1.4;
  }
  .highlight { background: yellow; color: black; padding: 2px 4px; }
  .error { color: #e74c3c; font-weight: bold; }
  .success { color: #27ae60; font-weight: bold; }
  button { 
    background: #667eea; 
    color: white; 
    border: none; 
    padding: 12px 24px; 
    font-size: 16px; 
    border-radius: 4px; 
    cursor: pointer; 
  }
  button:hover { background: #5568d3; }
</style>
</head>
<body>
<h1>ğŸ” è¿½è¸ªè°ƒè¯• - æŸ¥æ‰¾é‡å¤æºå¤´</h1>
<button onclick="startDebug()">å¼€å§‹è°ƒè¯•</button>
<div id="output"></div>

<script src="dist/trafilatura.browser.js"></script>
<script>
function startDebug() {
  const output = document.getElementById('output');
  output.innerHTML = '';
  
  const html = `
    <html><body>
      <article>
        <p><strong>æœ¬ç§‘å½•å–åé¢é¢„è®¡ä¸º450ä¸‡</strong></p>
        <p><strong>2024å¹´å…¨å›½é«˜è€ƒæŠ¥åäººæ•°ä¸º1353ä¸‡</strong>ï¼Œæ¯”2023å¹´å¤šå‡º62ä¸‡äººã€‚</p>
      </article>
    </body></html>
  `;
  
  addStep('ğŸ“¥ æ­¥éª¤1: è¾“å…¥HTML', html);
  
  // ä½¿ç”¨bareExtractionè·å–Documentå¯¹è±¡
  const doc = Trafilatura.bareExtraction(html, {
    include_formatting: true,
    include_links: true
  });
  
  if (!doc || !doc.body) {
    addStep('âŒ é”™è¯¯', 'æå–å¤±è´¥', true);
    return;
  }
  
  // åºåˆ—åŒ–XMLæŸ¥çœ‹ç»“æ„
  const xmlStr = new XMLSerializer().serializeToString(doc.body);
  addStep('ğŸ“‹ æ­¥éª¤2: æå–åçš„XMLç»“æ„', formatXml(xmlStr));
  
  // åˆ†æbodyç»“æ„
  let analysis = '';
  analysis += `Bodyæ ‡ç­¾: <${doc.body.tagName}>\n`;
  analysis += `Bodyå­å…ƒç´ æ•°é‡: ${doc.body.children.length}\n\n`;
  
  // éå†æ‰€æœ‰å­å…ƒç´ 
  for (let i = 0; i < doc.body.children.length; i++) {
    const child = doc.body.children[i];
    analysis += analyzeElement(child, 0);
  }
  
  addStep('ğŸ” æ­¥éª¤3: ç»“æ„åˆ†æ', analysis);
  
  // æ”¶é›†æ‰€æœ‰æ–‡æœ¬
  const allTexts = [];
  collectTexts(doc.body, allTexts);
  
  let textAnalysis = 'æå–åˆ°çš„æ‰€æœ‰æ–‡æœ¬ç‰‡æ®µï¼š\n\n';
  allTexts.forEach((text, index) => {
    textAnalysis += `${index + 1}. "${text}"\n`;
  });
  
  addStep('ğŸ“ æ­¥éª¤4: æ‰€æœ‰æ–‡æœ¬ç‰‡æ®µ', textAnalysis);
  
  // æµ‹è¯•ä¸åŒæ ¼å¼
  const txtResult = Trafilatura.extract(html, { format: 'txt' });
  addStep('ğŸ“„ æ­¥éª¤5: TXTè¾“å‡º', txtResult || '(ç©º)');
  
  const mdResult = Trafilatura.extract(html, { format: 'markdown' });
  addStep('ğŸ“„ æ­¥éª¤6: Markdownè¾“å‡º', mdResult || '(ç©º)');
  
  // æ£€æŸ¥é‡å¤
  const pattern1 = 'æœ¬ç§‘å½•å–åé¢é¢„è®¡ä¸º450ä¸‡';
  const pattern2 = '2024å¹´å…¨å›½é«˜è€ƒæŠ¥åäººæ•°ä¸º1353ä¸‡';
  
  const count1 = (txtResult.match(new RegExp(escapeRegex(pattern1), 'g')) || []).length;
  const count2 = (txtResult.match(new RegExp(escapeRegex(pattern2), 'g')) || []).length;
  
  let result = `æ£€æŸ¥ç»“æœï¼š\n\n`;
  result += `"${pattern1}" å‡ºç°æ¬¡æ•°: ${count1}\n`;
  result += `"${pattern2}" å‡ºç°æ¬¡æ•°: ${count2}\n\n`;
  
  if (count1 > 1 || count2 > 1) {
    result += 'âŒ å‘ç°é‡å¤ï¼\n\n';
    
    // åˆ†æé‡å¤ä½ç½®
    result += 'é‡å¤ä½ç½®åˆ†æï¼š\n';
    const lines = txtResult.split('\n');
    lines.forEach((line, i) => {
      if (line.includes(pattern1)) {
        result += `ç¬¬${i+1}è¡ŒåŒ…å«"æœ¬ç§‘å½•å–åé¢": ${line}\n`;
      }
      if (line.includes(pattern2)) {
        result += `ç¬¬${i+1}è¡ŒåŒ…å«"é«˜è€ƒæŠ¥åäººæ•°": ${line}\n`;
      }
    });
  } else {
    result += 'âœ… æ— é‡å¤ï¼ä¿®å¤æˆåŠŸï¼';
  }
  
  addStep(count1 > 1 || count2 > 1 ? 'âŒ æ­¥éª¤7: æ£€æŸ¥ç»“æœ' : 'âœ… æ­¥éª¤7: æ£€æŸ¥ç»“æœ', result, count1 > 1 || count2 > 1);
}

function analyzeElement(elem, level) {
  const indent = '  '.repeat(level);
  let result = '';
  
  result += `${indent}<${elem.tagName.toLowerCase()}`;
  
  // æ˜¾ç¤ºå±æ€§
  if (elem.attributes.length > 0) {
    for (const attr of elem.attributes) {
      result += ` ${attr.name}="${attr.value}"`;
    }
  }
  result += '>\n';
  
  // æ˜¾ç¤ºç›´æ¥æ–‡æœ¬å†…å®¹ï¼ˆç¬¬ä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹ï¼‰
  const firstChild = elem.firstChild;
  if (firstChild && firstChild.nodeType === Node.TEXT_NODE) {
    const text = firstChild.textContent.trim();
    if (text) {
      result += `${indent}  [text] "${text}"\n`;
    }
  }
  
  // æ˜¾ç¤ºæ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
  let textNodeCount = 0;
  for (const node of elem.childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      textNodeCount++;
      const text = node.textContent.trim();
      if (text) {
        result += `${indent}  [textNode${textNodeCount}] "${text}"\n`;
      }
    }
  }
  
  // é€’å½’å¤„ç†å­å…ƒç´ 
  for (const child of elem.children) {
    result += analyzeElement(child, level + 1);
  }
  
  // æ£€æŸ¥tailï¼ˆnextSiblingæ–‡æœ¬èŠ‚ç‚¹ï¼‰
  if (elem.nextSibling && elem.nextSibling.nodeType === Node.TEXT_NODE) {
    const tail = elem.nextSibling.textContent.trim();
    if (tail) {
      result += `${indent}  [tail] "${tail}"\n`;
    }
  }
  
  result += `${indent}</${elem.tagName.toLowerCase()}>\n`;
  
  return result;
}

function collectTexts(elem, texts) {
  // æ”¶é›†å½“å‰å…ƒç´ çš„æ–‡æœ¬
  for (const node of elem.childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent.trim();
      if (text) {
        texts.push(text);
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      collectTexts(node, texts);
    }
  }
}

function addStep(title, content, isError = false) {
  const output = document.getElementById('output');
  const step = document.createElement('div');
  step.className = 'step';
  
  const titleElem = document.createElement('h2');
  titleElem.innerHTML = title;
  
  const contentElem = document.createElement('pre');
  contentElem.textContent = content;
  
  step.appendChild(titleElem);
  step.appendChild(contentElem);
  output.appendChild(step);
}

function formatXml(xml) {
  let formatted = '';
  let indent = '';
  const tab = '  ';
  
  xml.split(/>\s*</).forEach((node, index) => {
    if (node.match(/^\/\w/)) {
      indent = indent.substring(tab.length);
    }
    
    formatted += indent;
    if (index > 0) formatted += '<';
    formatted += node;
    if (index < xml.split(/>\s*</).length - 1) formatted += '>';
    formatted += '\n';
    
    if (node.match(/^<?\w[^>]*[^\/]$/) && !node.startsWith('/')) {
      indent += tab;
    }
  });
  
  return formatted;
}

function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
</script>
</body>
</html>

